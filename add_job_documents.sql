-- Add job_documents table for document management
CREATE TABLE IF NOT EXISTS job_documents (
  id bigint generated by default as identity primary key,
  job_id bigint references jobs ON DELETE CASCADE not null,
  user_id uuid references auth.users not null,
  filename text not null,
  file_path text not null,
  file_size bigint,
  mime_type text,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

-- Enable RLS
ALTER TABLE job_documents ENABLE ROW LEVEL SECURITY;

-- Add CASCADE DELETE to foreign key
ALTER TABLE job_documents DROP CONSTRAINT IF EXISTS job_documents_job_id_fkey;
ALTER TABLE job_documents ADD CONSTRAINT job_documents_job_id_fkey FOREIGN KEY (job_id) REFERENCES jobs(id) ON DELETE CASCADE;

-- RLS Policies for job_documents
DROP POLICY IF EXISTS "Users can view documents on accessible jobs" ON job_documents;
CREATE POLICY "Users can view documents on accessible jobs" ON job_documents
  FOR SELECT USING (
    -- User owns the document
    auth.uid() = user_id
    -- OR user has access to the job the document belongs to
    OR EXISTS (
      SELECT 1 FROM jobs j
      WHERE j.id = job_documents.job_id
      AND (
        -- User owns the job
        j.user_id = auth.uid()
        -- OR user is super_admin
        OR EXISTS (
          SELECT 1 FROM user_roles ur
          JOIN roles r ON ur.role_id = r.id
          WHERE ur.user_id = auth.uid() AND r.name = 'super_admin'
        )
        -- OR user has global role that allows reading all jobs
        OR EXISTS (
          SELECT 1 FROM user_roles ur
          JOIN roles r ON ur.role_id = r.id
          WHERE ur.user_id = auth.uid()
          AND r.permissions->'jobs'->>'read' = 'all'
        )
        -- OR user has global role with 'assigned' permissions AND is assigned to this job
        OR EXISTS (
          SELECT 1 FROM user_roles ur
          JOIN roles r ON ur.role_id = r.id
          JOIN job_assignments ja ON ja.user_id = auth.uid()
          WHERE ur.user_id = auth.uid() AND ja.job_id = j.id
          AND r.permissions->'jobs'->>'read' IN ('assigned', 'assigned_or_created')
        )
      )
    )
  );

DROP POLICY IF EXISTS "Users can upload documents on accessible jobs" ON job_documents;
CREATE POLICY "Users can upload documents on accessible jobs" ON job_documents
  FOR INSERT WITH CHECK (
    auth.uid() = user_id
    AND EXISTS (
      SELECT 1 FROM jobs j
      WHERE j.id = job_documents.job_id
      AND (
        -- User owns the job
        j.user_id = auth.uid()
        -- OR user is super_admin
        OR EXISTS (
          SELECT 1 FROM user_roles ur
          JOIN roles r ON ur.role_id = r.id
          WHERE ur.user_id = auth.uid() AND r.name = 'super_admin'
        )
        -- OR user has global role that allows writing to all jobs
        OR EXISTS (
          SELECT 1 FROM user_roles ur
          JOIN roles r ON ur.role_id = r.id
          WHERE ur.user_id = auth.uid()
          AND r.permissions->'jobs'->>'write' = 'all'
        )
        -- OR user has global role with 'assigned' permissions AND is assigned to this job
        OR EXISTS (
          SELECT 1 FROM user_roles ur
          JOIN roles r ON ur.role_id = r.id
          JOIN job_assignments ja ON ja.user_id = auth.uid()
          WHERE ur.user_id = auth.uid() AND ja.job_id = j.id
          AND r.permissions->'jobs'->>'write' IN ('assigned', 'assigned_or_created')
        )
      )
    )
  );

DROP POLICY IF EXISTS "Users can update documents they own" ON job_documents;
CREATE POLICY "Users can update documents they own" ON job_documents
  FOR UPDATE USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete documents they own" ON job_documents;
CREATE POLICY "Users can delete documents they own" ON job_documents
  FOR DELETE USING (auth.uid() = user_id);

-- Create storage bucket for documents
INSERT INTO storage.buckets (id, name, public)
VALUES ('job-documents', 'job-documents', false)
ON CONFLICT (id) DO NOTHING;

-- Storage policies for job-documents bucket
DROP POLICY IF EXISTS "Users can upload documents to accessible jobs" ON storage.objects;
CREATE POLICY "Users can upload documents to accessible jobs" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'job-documents'
    AND auth.uid()::text = (storage.foldername(name))[1]
  );

DROP POLICY IF EXISTS "Users can view documents on accessible jobs" ON storage.objects;
CREATE POLICY "Users can view documents on accessible jobs" ON storage.objects
  FOR SELECT USING (
    bucket_id = 'job-documents'
    AND EXISTS (
      SELECT 1 FROM job_documents jd
      WHERE jd.file_path = name
      AND EXISTS (
        SELECT 1 FROM jobs j
        WHERE j.id = jd.job_id
        AND (
          -- User owns the job
          j.user_id = auth.uid()
          -- OR user is super_admin
          OR EXISTS (
            SELECT 1 FROM user_roles ur
            JOIN roles r ON ur.role_id = r.id
            WHERE ur.user_id = auth.uid() AND r.name = 'super_admin'
          )
          -- OR user has global role that allows reading all jobs
          OR EXISTS (
            SELECT 1 FROM user_roles ur
            JOIN roles r ON ur.role_id = r.id
            WHERE ur.user_id = auth.uid()
            AND r.permissions->'jobs'->>'read' = 'all'
          )
          -- OR user has global role with 'assigned' permissions AND is assigned to this job
          OR EXISTS (
            SELECT 1 FROM user_roles ur
            JOIN roles r ON ur.role_id = r.id
            JOIN job_assignments ja ON ja.user_id = auth.uid()
            WHERE ur.user_id = auth.uid() AND ja.job_id = j.id
            AND r.permissions->'jobs'->>'read' IN ('assigned', 'assigned_or_created')
          )
        )
      )
    )
  );

DROP POLICY IF EXISTS "Users can update documents they own" ON storage.objects;
CREATE POLICY "Users can update documents they own" ON storage.objects
  FOR UPDATE USING (
    bucket_id = 'job-documents'
    AND auth.uid()::text = (storage.foldername(name))[1]
  );

DROP POLICY IF EXISTS "Users can delete documents they own" ON storage.objects;
CREATE POLICY "Users can delete documents they own" ON storage.objects
  FOR DELETE USING (
    bucket_id = 'job-documents'
    AND auth.uid()::text = (storage.foldername(name))[1]
  );